## 题目大意

有一颗 n 层的满二叉树，有 m 次操作：操作 1 是删除节点 u 的父边，操作 2 是统计节点 u 所在的连通图大小。

## 先做暴力

这题的50分中 n <= 20。可以计算一下：2^20 = 1048576。这个区间对应的树我们完全可以使用数组去建立，因为正好根节点为 1。因此我们直接开一个 1100000 大小的数组，用来存储节点的情况：此节点的父边是否断裂 opt[u]，以及此节点的子树大小 cnt[u]。

初始化一下这棵树：
```cpp
#define L(x) (x<<1)
#define R(x) ((x<<1)+1)
int build(int x, int depth) {
    cnt[x] = 1;
    if (depth == n) return 1;
    int l = build(L(x), depth + 1);
    int r = build(R(x), depth + 1);
    cnt[x] += l + r; // 计算子树大小
    return cnt[x];
}
```

我们先考虑如何统计一个节点 u 的连通图大小：很显然，只需要一直向上跳跃，直到不能再向上，那么此时统计子树大小即可。
```cpp
#define FA(x) (x>>1)
else if (o == 2) {
    // 没有删除 u 的边，就向上找
    while (!opt[u]) u = FA(u);
    ans ^= cnt[u];
}
```

然后考虑删边的影响：删除一条边之后，受影响的【子树大小】只和所有的祖先节点相关。那么我们的操作就是：寻找 u 的父亲 t1，然后 t1 减去子树 u 的大小；t1 的父节点 t2 也减去子树 u 的大小……
```cpp
#define FA(x) (x>>1)
if (o == 1 && !opt[u]) {
    int t = u;
    while (!opt[t]) {
        t = FA(t);
        cnt[t] -= cnt[u]; 
    }
    opt[u] = 1;
}
```

## 考虑正解
很显然当 n <= 60 的时候，我们无法直接通过下标表示这个节点信息了（不能开一个cnt[2^60]的数组）。数据范围计算：O(M*N) = 1.8e7。N 是层数，也就是每次操作我们会访问的节点数量。这个层级理论上只要我们能在 O(1) 的复杂度内访问一个节点，我们就能做。

但是很可惜，单纯的 unordered_map 常数过大，会导致 TLE。（使用read、循环展开、分层处理等等卡常操作可以通过，或者手写 Hash）

无论是 Map 还是手写 Hash，我们的目的都是把多余的无用节点给省略掉。因为操作数是 3e5，那么最多上限有用的节点可能是 1e6 的量级。所以我们考虑可以动态的建立这棵树：需要 u 点的时候，我们再把 u 的所有祖先建立出来。

问题的关键在于高效的建立一条路径通向 u。我们观察一下节点的编号关系，使用 Trie 是最好的：根节点为 1，向左为 “0” ，向右为 “1”。正好二进制下“10”和“11”代表 2 和 3。同理 4 和 5 正好对应的是“100”（根-左-左）和 “101”（根-左-右）。

那么一个节点 u 实际上就是一个二叉的 Trie，到达 u 之后正好就是它的二进制数字。

![alt text](image.png)

那么我们的算法就有了很好的思路了：遇到节点 u 的时候，直接从Trie的根节点跑到 u 对应的位置，然后对路径上所有的点进行相应操作处理就好了。

```cpp
#include <bits/stdc++.h>
#define L(x) (x<<1)
#define R(x) ((x<<1)+1)
#define FA(x) (x>>1)
#define ll long long
using namespace std;
int n, m;
ll ans = 0;
int cnt[1100000];
bool opt[1100000];

inline ll read() {
    ll read_num = 0, posibal = 1; char chh = 0;
    while (!isdigit(chh)) { if (chh=='-') posibal=-1;chh=getchar(); }
    while (isdigit(chh)) { read_num=read_num*10+(chh-'0');chh=getchar(); }
    return read_num * posibal;
}

int build(int x, int depth) {
    cnt[x] = 1;
    if (depth == n) return 1;
    int l = build(L(x), depth + 1);
    int r = build(R(x), depth + 1);
    cnt[x] += l + r;
    return cnt[x];
}

void baoli() {
    build(1, 1);
    opt[1] = 1;
    for (int i = 1; i <= m; ++i) {
        int o, u;
        cin >> o >> u;
        if (o == 1 && !opt[u]) {
            int t = u;
            while (!opt[t]) {
                t = FA(t);
                cnt[t] -= cnt[u];
            }
            opt[u] = 1;
        } else if (o == 2) {
            while (!opt[u]) u = FA(u);
            ans ^= cnt[u];
        }
    }
    cout << ans << endl;
}

struct Trie {
    ll sum;
    bool cut;
    int son[2];
}a[21000000];
int id;
int path[65];

void find(ll u, int h) {
    int p = 1, pu = 1;
    while((1LL << pu) <= u) ++pu;
    pu -= 2; // 找到下一个节点的位置
    path[pu+1] = 1, path[pu+2] = 0; // 往回找走了哪些点的话，最后一个一定是根，0用来结束循环
    while (pu >= 0) {
        --h;
        short b = u >> pu & 1;
        if (!a[p].son[b]) { // 需要新建节点的话
            a[p].son[b] = ++id;
            a[id].sum = (1LL << h) - 1; // 新节点的 sum 值
        }
        p = a[p].son[b];
        path[pu] = p; // 记录经过的 Trie 节点 id
        --pu;
    }
}

void solution() {
    a[0].cut = 1;
    a[1].sum = (1LL << n) - 1;
    id = 1;
    for (int i = 1; i <= m; ++i) {
        int o; ll u;
        o = read(); u = read();
        if (o == 1 && u != 1) {
            find(u, n); // path 数组中path[0]是 u 节点，path[1]是父节点...
            for (int p = 1; path[p]; ++p) {
                if (a[path[p-1]].cut) break;
                a[path[p]].sum -= a[path[0]].sum;
            }
            a[path[0]].cut = 1; // u 点删除边
        } else if (o == 2) {
            find(u, n);
            int p = 0;
            while (!a[path[p]].cut) ++p;
            if (path[p] == 0) ans ^= a[1].sum;
            else ans ^= a[path[p]].sum;
        }
    }
    cout << ans << endl;
}

int main() {
    n = read(), m = read();
    if (n <= 20) baoli(); // 比赛时，只要暴力写的对，小数据就用暴力跑，保证一定有分
    else solution();
    return 0;
}
```
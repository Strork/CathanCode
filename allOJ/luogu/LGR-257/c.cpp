#include <bits/stdc++.h>
using namespace std;
int n, m, k;

int main() {
    int T;
    cin >> T;
    while (T--) {
        cin >> n >> m >> k;
    }
    return 0;
}

// 推论：一旦用到第三个盒子，代表答案在附近（因为第二个盒子能尽快下降数量）
// 证明：假设为 100 50 1，显然不如99，52（代价相同）
// 但是 50 50 1，就不能改了。然后接下来对于 50，必须尽量平分： 17 17 16
// 你发现总能平分 假设 还是50，k=52,4个盒子： 17 17 16 0 对于 17， k = 52

// 2：反向考虑
// 1 -> m
